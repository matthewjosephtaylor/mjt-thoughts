# ALL Art Including the Art of Programming is Contextual

Early in life I used to think there was a 'right' way of programming, or a
'right' way of solving a programming problem.

I think this is a common disease and so want to write a few words to help those
who might likewise be afflicted with this idea of 'rightness' in programming.

## Warning

The words below are my own personal understanding and opinions on this subject.
They are carefully chosen, but like all opinions they are _fleeting_ and are an
expression of my thoughts at the _place_ and _time_ that I'm writing them from.

## My context

I'm an
[old software developer](https://www.linkedin.com/in/matthewjosephtaylor/) who
has been programming and building and messing around with computers since my
childhood. I've been fascinated by, devoted to, and have dedicated, a large part
of my life to programming. I'm a _practitioner_ not an _academic_. As the
tagline on my resume says I 'live to code, and code to live'.

# Programming is not Engineering, not a Science. It is more. It is Art

My understanding of the field of 'software development' aka 'programming' or
'coding' or any of the other names for writing 'source code' to be transformed
into something a _machine_ can usefully interpret, goes against the grain.

I beg to share my idea of what programming is, and why I rankle whenever someone
uses the term 'Computer Science' to describe what I do, or calls myself and
other software developers/programmers 'software engineers'. I don't take
offense, but it rubs me the wrong way, like when someone mispronounces a word I
think _ought_ to be pronounced the way I say it.

Engineering according to wikipedia is
[the use of scientific principles to design and build machines](https://en.wikipedia.org/wiki/Engineering)

Science according to wikipedia is
[a systematic enterprise that builds and organizes knowledge in the form of testable explanations and predictions about the universe](https://en.wikipedia.org/wiki/Science)

I think both of these definitions are reasonable and align well with my
thinking.

Note that engineering is about _building machines_ and science is about
_building knowledge_.

Also note that engineering is NOT science, it _uses_ science.

Science itself uses things like _logic_ but one would not say science _is_
logic. Logic is just a tool to science, as science is a tool to engineering.

So both science and engineering _use_ logic, which itself is another field that
has its own set of things it depends upon, ad infinitum...

I think it is fair to say that 'software development' in a similar way _uses_
some engineering principles, just as engineering uses some scientific
principles. But I would not call programming 'engineering' anymore than I think
an engineer would call what they do 'science-ing'.

The other additional component that I think is _too often_ overlooked (even by
programmers) is that programming uses other fields like
[_linguistics_](https://en.wikipedia.org/wiki/Linguistics) (study of language),
and
[_semantics_](https://en.wikipedia.org/wiki/Semantics)/[_epistemology_](https://en.wikipedia.org/wiki/Epistemology)
(study of meaning).

Engineering is about _making_ a machine that _moves_ in a desired way by making
use of the given laws of physics.

Programming is about telling the machine a _meaningful_ story, so well crafted,
that it is compelled to move of its own accord. It is the equivalent to
_uttering_ a _magic spell_ and watching the machine 'come to life'.

As a programmer I think of an idea, and if I _speak_ it clearly enough, the
universe _obeys_.

> And God said, Let there be light: and there was light. -- Bible, King James
> Version

There are names for someone who studies and speaks special languages, whose mere
words can have powerful direct effects upon the world. They are sometimes called
_wizards_, or _magicians_, if they become powerful enough, it is hard to
distinguish them from _gods_ (what would you call an entity that 'spoke a world
into being'?).

I don't claim any of these titles, but I think it is important to know this is
the _area_ one is delving into by programming. This isn't just engineering, this
isn't just science. This is _world building_.

As a programmer, I do this:

```js
type Darkness = 0;
type Light = 1;
type Visible = Darkness | Light;
```

(this reads as 'there is a kind of thing called 'Visible' that is either
'Darkness' or 'Light').

The important thing to note is that this isn't just 'kind of like' that famous
verse from the Bible, I claim it is _deeply_ equivalent, and that this is an
important thing to understand if one wishes to understand the act of
'programming' and how it differs from 'engineering' or 'science'.

In programming, I'm not acting as a scientist trying to 'figure out' the world.
There is nothing easily recognized as science going on. Whatever
meaning/knowledge exists, is the meaning I the programmer am creating, no need
to attempt to _hypothesize/test-for_ knowledge/meaning, I'm _building_ meaning
by _communicating_ with _language_.

I'm not putting together a 'machine' with a _purpose_ in the above code (What is
the purpose of Darkness other than to act as the opposite of Light?). There is
no recognizable engineering going on. True this may _eventually_ run on a
machine which will 'do something', but maybe not. This source code may _never_
be compiled outside of this post, yet it still serves to _communicate_ with
_language_ and therefore create _meaning_.

I have 'spoken' and created 'light' by _dividing_ light from darkness.

I have now _created_ a universe with light and dark. I can build upon this and
create whatever my _creativity_ and _imagination_ allows me by combining
_language_ and _meaning_ to tell a story. It is more akin to writing a novel,
that creates a world for those who read it.

But programming is a bit more than writing literature, which are stores only
other humans can read.

If I now combine this new universe with _engineering_, I can have this new
creation affect other worlds such as the 'real' or 'physical' world in a
_reliable_ way (engineering principles are handy for reliability). All I have to
do is create a _mapping_ between the world I created, and the world I want to
connect it with.

In programming we call this mapping thing 'compiling the source code' to a
particular _target machine_ . The _machine_ is the thing that acts on behalf of
the compiled program. The compiled 'thing' is often called an 'executable', but
it is a _direct translation_ of the original source code the programmer wrote
(or 'spoke' or 'uttered'), to another _language_ that a particular machine can
'read' or 'understand'.

Side note: Sometimes we use funny words like 'daemon' for some of our creations
that act on our behalf between worlds...because some of us have retained a sense
of humor about the whole thing. :)

## What is the difference between an Art and a Science?

Science is concerned with _gaining_ knowledge for its own sake.

Art is about the _application_ of knowledge to achieve some effect upon the
world. It is about crafting and making things, or other forms of 'expressing' a
thought or idea upon the world like dancing or singing a song.

> The easiest way to do something is the right way -- unknown

I read the above in a science fiction book long ago (can't remember the name of
the author/book (if you know please let me know and I'll update, the main
character was an engineer, and he was driven from his society because he dared
to invent a new thing as I recall)).

This quote stuck with me because of its hidden 'truism'. One could also say 'the
right way to do something is the easy way'.

Once one knows 'a way' to do something, that way becomes 'the way' to do that
thing. Once one discovers 'another way' of doing something then the _right_ way
is whichever way is 'easiest'.

So what is 'the easiest'?

There is no 'the' answer to this question.

Easy is time and place (aka context) sensitive. There is no single 'easy' way of
doing something. The answer to 'easy' _depends_ on the _context_.

Put another way: there is no 'right way' of doing something. The 'right way'
_always_ depends on _context_.

What is the 'right song', or the 'right painting', or the 'right clothing'?

This goes deeper...

When painting, what is the 'right color' to use?

When singing, what is the 'right tempo' to sing in?

When choosing a pair of shoes, what is the 'right style' to choose?

And deeper....

When color choosing, what is the 'right pigment' to use?

etc... (hopefully you get the point)

'Right' depends on context, but also critically depends on _what possibilities_
exist, and what _constraints_ (limits) one is working under and I will claim is
always a _subjective_ choice.

## Questions and Answers

What is the 'right' programming language? What is the 'right' programming
paradigm? What is the 'right' abstraction? What is the 'right' pattern? What is
the 'right' name for this variable?

There _is_ no 'right' answer, there is only the 'easiest' answer that happens to
be at one's disposal at this _time_ and _place_.

What one programmer chooses in answer to these questions will _always_ be
somewhat different than what another programmer chooses (maybe event that same
individual the next day).

What is the 'right fashion' of dress to wear? Some would say whatever happens to
be 'in style' at the time. Others might argue that there are certain dresses
that are 'timeless' and to go with those. Still others might wear what is
comfortable, or something personally meaningful (like grandma's wedding dress).

After much careful consideration I therefore say: one should choose whichever
'feels' the easiest at the time, and not worry too much about it. This also
means don't focus too much about things being 'wrong'. Make it a bit better if
one is so inclined, otherwise accept the 'wrongness' as a 'flavor' or 'style'
that is not to one's present taste. It is OK to be and allow others to be
'wrong'. It is also OK to attempt to 'right' a 'wrong', but know this is an
endless task, which can bring joy or suffering depending on how it is
approached.

Yes, that means programming, like _all_ creative endeavors is based on _personal
taste_, and everyone is going to be a bit different. I'll further argue that
this is _OK_ and _healthy_ to have a wide range of styles and tastes in the
wild, because that is what makes all forms of art fun and interesting and
worthwhile.

'Solved' games are boring, and not worth the effort of playing.

I don't see programming ever being 'solved', for the same reasons that I don't
see any other form of art from cooking to chair-making being 'solved'. There may
be fashion trends that stick around for longer or shorter periods, but the
possibility space is so large, and there are so many _interesting_ stories to
tell that I have no fear of becoming bored as a programmer.

## Conclusion

Whatever one does _today_ will always be re-interpreted as 'right' or 'wrong' in
the future depending on the _context_ of whomever is looking back (even one's
self). Don't sweat it. Have fun, and create the 'right' thing in this moment. :)
